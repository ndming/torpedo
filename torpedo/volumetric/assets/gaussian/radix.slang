import splat;

[[vk::push_constant]]
uniform RasterInfo info;

[[vk::binding(7)]]
RWStructuredBuffer<uint64_t> keys;

[[vk::binding(8)]]
RWStructuredBuffer<uint> vals;

[[vk::binding(9)]]
RWStructuredBuffer<uint> blockSums;

[[vk::binding(10)]]
RWStructuredBuffer<uint> localSums;

struct LocalOffset {
    uint data[WORKGROUP_SIZE];
}

groupshared uint64_t localKeys[WORKGROUP_SIZE];
groupshared uint bufferIndices[WORKGROUP_SIZE];
groupshared LocalOffset offsets[4];

// Performs radix sort on the key/value pairs generated by keygen.slang, based on:
// 4-way radix sort: https://www.sci.utah.edu/~csilva/papers/cgf.pdf
// Optimized reduction: https://developer.download.nvidia.com/assets/cuda/files/reduction.pdf

[shader("compute")]
[numthreads(WORKGROUP_SIZE / 2, 1, 1)] // each thread (invocation) processes 2 items
void main(uint3 localInvocationID : SV_GroupThreadID, uint3 groupID : SV_GroupID) {
    let localID = localInvocationID.x; // [0, WORKGROUP_SIZE / 2 - 1]
    // let laneID = WaveGetLaneIndex();
    // let subgroupID = localID / WaveGetLaneCount();

    // The starting index in the global array for this partition
    let begin = groupID.x * WORKGROUP_SIZE;

    // Load global data into shared memory, each thread grabs 2 items seprated by WORKGROUP_SIZE / 2 stride
    let aj = localID;
    let bj = localID + WORKGROUP_SIZE / 2;
    localKeys[aj] = begin + aj < info.tilesRendered ? keys[begin + aj] : uint64_t::maxValue;
    localKeys[bj] = begin + bj < info.tilesRendered ? keys[begin + bj] : uint64_t::maxValue;
    bufferIndices[aj] = begin + aj < info.tilesRendered ? vals[begin + aj] : 0;
    bufferIndices[bj] = begin + bj < info.tilesRendered ? vals[begin + bj] : 0;

    // Generate mask for each 2-bit radix
    let shift = 2 * info.radixPass;
    let keyA = uint((localKeys[aj] >> shift) & 0x3ULL);
    let keyB = uint((localKeys[bj] >> shift) & 0x3ULL);
    offsets[0].data[aj] = uint(keyA == 0); offsets[0].data[bj] = uint(keyB == 0);
    offsets[1].data[aj] = uint(keyA == 1); offsets[1].data[bj] = uint(keyB == 1);
    offsets[2].data[aj] = uint(keyA == 2); offsets[2].data[bj] = uint(keyB == 2);
    offsets[3].data[aj] = uint(keyA == 3); offsets[3].data[bj] = uint(keyB == 3);

    // Upsweep reduction
    uint offset = 1;
    for (uint d = WORKGROUP_SIZE >> 1; d > 0; d >>= 1) {
        // Ensure all values at the previous level have been computed and visible
        GroupMemoryBarrierWithGroupSync();

        if (localID < d) {
            let ai = offset * (2 * localID + 1) - 1;
            let bi = offset * (2 * localID + 2) - 1;

            offsets[0].data[bi] += offsets[0].data[ai];
            offsets[1].data[bi] += offsets[1].data[ai];
            offsets[2].data[bi] += offsets[2].data[ai];
            offsets[3].data[bi] += offsets[3].data[ai];
        }
        offset *= 2;
    }

    if (localID == 0) {
        let n = WORKGROUP_SIZE;

        // Pack 4 radix sums into a single 32-bit integer
        let s0 = offsets[0].data[n - 1];
        let s1 = offsets[1].data[n - 1] << 8;
        let s2 = offsets[2].data[n - 1] << 16;
        let s3 = offsets[3].data[n - 1] << 24;
        blockSums[groupID.x] = s3 | s2 | s1 | s0;

        // Set the last element of each offset array to the sum of the preceding radix combination
        offsets[3].data[n - 1] = offsets[2].data[n - 1] + offsets[1].data[n - 1] + offsets[0].data[n - 1];
        offsets[2].data[n - 1] = offsets[1].data[n - 1] + offsets[0].data[n - 1];
        offsets[1].data[n - 1] = offsets[0].data[n - 1];
        offsets[0].data[n - 1] = 0;
    }

    // Downsweep partial sum
    for (uint d = 1; d < WORKGROUP_SIZE; d *= 2) {
        offset >>= 1;
        GroupMemoryBarrierWithGroupSync();

        if (localID < d) {
            let ai = offset * (2 * localID + 1) - 1;
            let bi = offset * (2 * localID + 2) - 1;

            let t0 = offsets[0].data[ai];
            offsets[0].data[ai] = offsets[0].data[bi];
            offsets[0].data[bi] += t0;

            let t1 = offsets[1].data[ai];
            offsets[1].data[ai] = offsets[1].data[bi];
            offsets[1].data[bi] += t1;

            let t2 = offsets[2].data[ai];
            offsets[2].data[ai] = offsets[2].data[bi];
            offsets[2].data[bi] += t2;

            let t3 = offsets[3].data[ai];
            offsets[3].data[ai] = offsets[3].data[bi];
            offsets[3].data[bi] += t3;
        }
    }

    // Shuffle local keys and indices and write to global memory
    GroupMemoryBarrierWithGroupSync();
    let idxA = offsets[keyA].data[aj];
    let idxB = offsets[keyB].data[bj];

    if (begin + idxA < info.tilesRendered) {
        keys[begin + idxA] = localKeys[aj];
        vals[begin + idxA] = bufferIndices[aj];
    }
    if (begin + idxB < info.tilesRendered) {
        keys[begin + idxB] = localKeys[bj];
        vals[begin + idxB] = bufferIndices[bj];
    }

    // Per-block local prefix sums are also written for each radix combination
    if (begin + aj < info.tilesRendered) localSums[begin + aj] = idxA;
    if (begin + bj < info.tilesRendered) localSums[begin + bj] = idxB;
}