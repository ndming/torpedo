import splat;

[[vk::push_constant]]
uniform RasterInfo info;

[[vk::binding(7)]]
RWStructuredBuffer<uint64_t> splatKeys;

[[vk::binding(8)]]
RWStructuredBuffer<uint> splatIndices;

[[vk::binding(5)]]
RWStructuredBuffer<uint> partitionCount;

[[vk::binding(9)]]
RWStructuredBuffer<uint64_t> blockDescriptors0; // flag (2 bits) - radix 1 (31 bits) - radix 0 (31 bits)

[[vk::binding(10)]]
RWStructuredBuffer<uint64_t> blockDescriptors1; // flag (2 bits) - radix 3 (31 bits) - radix 2 (31 bits)

[[vk::binding(11)]]
RWStructuredBuffer<uint64_t> globalSums; // array of 3 64-bit integers, each is a flag (1 bit) - sum radix i (32 bits) 

struct LocalOffset {
    uint data[WORKGROUP_SIZE];
}

groupshared LocalOffset offsets[4];
groupshared uint partition; // which part of the global array this workgroup is resonsible for
groupshared uint64_t value; // global values from other workgroups are read into this variable

#define NUM_BANKS 16 // half the SIMD width
#define LOG_NUM_BANKS 4
#define CONFLICT_FREE_OFFSET(n)((n) >> NUM_BANKS + (n) >> (2 * LOG_NUM_BANKS))

static const uint FLAG_X = 0u; // invalid
static const uint FLAG_A = 1u; // aggregate available
static const uint FLAG_P = 2u; // prefix available

// For atomic read of block descriptors
static const uint64_t DUMMY = uint64_t::maxValue;

// Performs radix sort on the key/value pairs generated by keygen.slang, based on:
// 4-way radix sort: https://www.sci.utah.edu/~csilva/papers/cgf.pdf

[shader("compute")]
[numthreads(WORKGROUP_SIZE / 2, 1, 1)] // each thread (invocation) processes 2 items
void main(uint3 localInvocationID : SV_GroupThreadID, uint3 groupID : SV_GroupID) {
    let localID = localInvocationID.x; // [0, WORKGROUP_SIZE / 2 - 1]

    // Acquire partition and initialize block descriptors
    if (localID == 0) {
        InterlockedAdd(partitionCount[0], 1, partition);
        InterlockedExchange(blockDescriptors0[partition], 0);
        InterlockedExchange(blockDescriptors1[partition], 0);

        // Let workgroup responsible for partition 0 initialize the global sums
        if (partition == 0) {
            InterlockedExchange(globalSums[0], 0);
            InterlockedExchange(globalSums[1], 0);
            InterlockedExchange(globalSums[2], 0);
        }
    }
    // Wait until thread 0 has obtained the partition for this workgroup
    GroupMemoryBarrierWithGroupSync();

    // The starting index in the global array for this partition
    let begin = partition * WORKGROUP_SIZE;

    // Each thread grabs 2 items and operates at conflict-free offsets
    let aj = localID;
    let bj = localID + WORKGROUP_SIZE / 2;
    let bankOffsetA = CONFLICT_FREE_OFFSET(aj);
    let bankOffsetB = CONFLICT_FREE_OFFSET(bj);

    // Get the key and value (splat index) for each item
    let kA = begin + aj < info.tilesRendered ? splatKeys[begin + aj] : uint64_t::maxValue;
    let kB = begin + bj < info.tilesRendered ? splatKeys[begin + bj] : uint64_t::maxValue;
    let vA = begin + aj < info.tilesRendered ? splatIndices[begin + aj] : 0;
    let vB = begin + bj < info.tilesRendered ? splatIndices[begin + bj] : 0;

    // Generate mask for each 2-bit radix
    let shift = 2 * info.radixPass;
    let keyA = uint((kA >> shift) & 0x3ULL);
    let keyB = uint((kB >> shift) & 0x3ULL);
    offsets[0].data[aj + bankOffsetA] = uint(keyA == 0); offsets[0].data[bj + bankOffsetB] = uint(keyB == 0);
    offsets[1].data[aj + bankOffsetA] = uint(keyA == 1); offsets[1].data[bj + bankOffsetB] = uint(keyB == 1);
    offsets[2].data[aj + bankOffsetA] = uint(keyA == 2); offsets[2].data[bj + bankOffsetB] = uint(keyB == 2);
    offsets[3].data[aj + bankOffsetA] = uint(keyA == 3); offsets[3].data[bj + bankOffsetB] = uint(keyB == 3);

    // Upsweep reduction
    uint offset = 1;
    for (uint d = WORKGROUP_SIZE >> 1; d > 0; d >>= 1) {
        // Ensure all values at the previous level have been computed and visible
        GroupMemoryBarrierWithGroupSync();

        if (localID < d) {
            var ai = offset * (2 * localID + 1) - 1;
            var bi = offset * (2 * localID + 2) - 1;
            ai += CONFLICT_FREE_OFFSET(ai);
            bi += CONFLICT_FREE_OFFSET(bi);

            offsets[0].data[bi] += offsets[0].data[ai];
            offsets[1].data[bi] += offsets[1].data[ai];
            offsets[2].data[bi] += offsets[2].data[ai];
            offsets[3].data[bi] += offsets[3].data[ai];
        }
        offset *= 2;
    }

    // Update this workgroup to aggregate-available state, each s* uses 31 bits and only valid for thread 0
    let s0 = offsets[0].data[WORKGROUP_SIZE - 1 + CONFLICT_FREE_OFFSET(WORKGROUP_SIZE - 1)];
    let s1 = offsets[1].data[WORKGROUP_SIZE - 1 + CONFLICT_FREE_OFFSET(WORKGROUP_SIZE - 1)];
    let s2 = offsets[2].data[WORKGROUP_SIZE - 1 + CONFLICT_FREE_OFFSET(WORKGROUP_SIZE - 1)];
    let s3 = offsets[3].data[WORKGROUP_SIZE - 1 + CONFLICT_FREE_OFFSET(WORKGROUP_SIZE - 1)];
    if (localID == 0 && partition > 0) {
        let a0 = (uint64_t(FLAG_A) << 62) | (uint64_t(s1) << 31) | uint64_t(s0);
        let a1 = (uint64_t(FLAG_A) << 62) | (uint64_t(s3) << 31) | uint64_t(s2);
        InterlockedExchange(blockDescriptors0[partition], a0);
        InterlockedExchange(blockDescriptors1[partition], a1);
    } else if (localID == 0) {
        // The first partition updates to prefix-available state
        let p0 = (uint64_t(FLAG_P) << 62) | (uint64_t(s1) << 31) | uint64_t(s0);
        let p1 = (uint64_t(FLAG_P) << 62) | (uint64_t(s3) << 31) | uint64_t(s2);
        InterlockedExchange(blockDescriptors0[partition], p0);
        InterlockedExchange(blockDescriptors1[partition], p1);
    }

    // Decoupled lookback for radix 0 and 1: find the prefix sum of each radix combination
    var globalPrefix0 = 0u;
    var globalPrefix1 = 0u;
    if (partition > 0) {
        var lookbackPartition = partition - 1;
        while (true) {
            // TODO: have an entire SIMD workgroups inspecting predecessors in parallel (parallelized look-back)
            if (localID == 0) InterlockedCompareExchange(blockDescriptors0[lookbackPartition], DUMMY, DUMMY, value);
            GroupMemoryBarrierWithGroupSync(); // wait for thread 0 to obtain the descriptor value

            let flag = uint(value >> 62);
            if (flag != FLAG_X) {
                // Accumulate the aggregate/inclusive prefix
                globalPrefix0 += uint(value & 0x7FFFFFFFULL);
                globalPrefix1 += uint((value >> 31) & 0x7FFFFFFFULL);
                if (flag == FLAG_A) --lookbackPartition;
                else break; // FLAG_P
            }
            // FLAG_X, spin
        }
    }

    // Decoupled lookback for radix 2 and 3: find the prefix sum of each radix combination
    var globalPrefix2 = 0u;
    var globalPrefix3 = 0u;
    if (partition > 0) {
        var lookbackPartition = partition - 1;
        while (true) {
            // TODO: have an entire SIMD workgroups inspecting predecessors in parallel (parallelized look-back)
            if (localID == 0) InterlockedCompareExchange(blockDescriptors1[lookbackPartition], DUMMY, DUMMY, value);
            GroupMemoryBarrierWithGroupSync(); // wait for thread 0 to obtain the descriptor value

            let flag = uint(value >> 62);
            if (flag != FLAG_X) {
                // Accumulate the aggregate/inclusive prefix
                globalPrefix2 += uint(value & 0x7FFFFFFFULL);
                globalPrefix3 += uint((value >> 31) & 0x7FFFFFFFULL);
                if (flag == FLAG_A) --lookbackPartition;
                else break; // FLAG_P
            }
            // FLAG_X, spin
        }
    }

    // Compute and record the partition-wide inclusive prefixes
    if (localID == 0 && partition > 0) {
        let p0 = (uint64_t(FLAG_P) << 62) | (uint64_t(s1 + globalPrefix1) << 31) | uint64_t(s0 + globalPrefix0);
        let p1 = (uint64_t(FLAG_P) << 62) | (uint64_t(s3 + globalPrefix3) << 31) | uint64_t(s2 + globalPrefix2);
        InterlockedExchange(blockDescriptors0[partition], p0);
        InterlockedExchange(blockDescriptors1[partition], p1);
    }

    // The last partition writes the total sum of each radix to global sums and resets the atomic counter
    let workgroupCount = (info.tilesRendered + WORKGROUP_SIZE - 1) / WORKGROUP_SIZE;
    if (partition == workgroupCount - 1 && localID == 0) {
        let g0 = (1ULL << 32) | uint64_t(s0 + globalPrefix0);
        let g1 = (1ULL << 32) | uint64_t(s1 + globalPrefix1);
        let g2 = (1ULL << 32) | uint64_t(s2 + globalPrefix2);
        InterlockedExchange(globalSums[0], g0);
        InterlockedExchange(globalSums[1], g1);
        InterlockedExchange(globalSums[2], g2);

        partitionCount[0] = 0;
    }

    // Acquire the global sums
    var globalSum0 = 0u;
    var globalSum1 = 0u;
    var globalSum2 = 0u;
    while (true) {
        if (localID == 0) InterlockedCompareExchange(globalSums[0], DUMMY, DUMMY, value);
        GroupMemoryBarrierWithGroupSync(); // wait for thread 0 to obtain the global sum value

        let valid = bool(value >> 32);
        if (valid) {
            globalSum0 = uint(value & 0xFFFFFFFFULL);
            break;
        }
    }

    while (true) {
        if (localID == 0) InterlockedCompareExchange(globalSums[1], DUMMY, DUMMY, value);
        GroupMemoryBarrierWithGroupSync(); // wait for thread 0 to obtain the global sum value

        let valid = bool(value >> 32);
        if (valid) {
            globalSum1 = uint(value & 0xFFFFFFFFULL);
            break;
        }
    }

    while (true) {
        if (localID == 0) InterlockedCompareExchange(globalSums[2], DUMMY, DUMMY, value);
        GroupMemoryBarrierWithGroupSync(); // wait for thread 0 to obtain the global sum value

        let valid = bool(value >> 32);
        if (valid) {
            globalSum2 = uint(value & 0xFFFFFFFFULL);
            break;
        }
    }

    // Set the last element of each local offset array to their respective global prefix sum
    if (localID == 0) {
        let n = WORKGROUP_SIZE;
        offsets[3].data[n - 1 + CONFLICT_FREE_OFFSET(n - 1)] = globalPrefix3 + globalSum2 + globalSum1 + globalSum0;
        offsets[2].data[n - 1 + CONFLICT_FREE_OFFSET(n - 1)] = globalPrefix2 + globalSum1 + globalSum0;
        offsets[1].data[n - 1 + CONFLICT_FREE_OFFSET(n - 1)] = globalPrefix1 + globalSum0;
        offsets[0].data[n - 1 + CONFLICT_FREE_OFFSET(n - 1)] = globalPrefix0;
    }

    // Downsweep partial sum
    for (uint d = 1; d < WORKGROUP_SIZE; d *= 2) {
        offset >>= 1;
        GroupMemoryBarrierWithGroupSync();

        if (localID < d) {
            var ai = offset * (2 * localID + 1) - 1;
            var bi = offset * (2 * localID + 2) - 1;
            ai += CONFLICT_FREE_OFFSET(ai);
            bi += CONFLICT_FREE_OFFSET(bi);

            let t0 = offsets[0].data[ai];
            offsets[0].data[ai] = offsets[0].data[bi];
            offsets[0].data[bi] += t0;

            let t1 = offsets[1].data[ai];
            offsets[1].data[ai] = offsets[1].data[bi];
            offsets[1].data[bi] += t1;

            let t2 = offsets[2].data[ai];
            offsets[2].data[ai] = offsets[2].data[bi];
            offsets[2].data[bi] += t2;

            let t3 = offsets[3].data[ai];
            offsets[3].data[ai] = offsets[3].data[bi];
            offsets[3].data[bi] += t3;
        }
    }

    GroupMemoryBarrierWithGroupSync();
    let idxA = offsets[keyA].data[aj + bankOffsetA];
    let idxB = offsets[keyB].data[bj + bankOffsetB];

    if (idxA < info.tilesRendered) {
        splatKeys[idxA] = kA;
        splatIndices[idxA] = vA;
    }
    if (idxB < info.tilesRendered) {
        splatKeys[idxB] = kB;
        splatIndices[idxB] = vB;
    }
}